# 6. 무식하게 풀기

<br/>

흔히 전산학에서 ‘`무식하게 푼다(brute-force)`’라는 말은  
컴퓨터의 빠른 계산 능력을 이용해 **가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법**을 의미한다.

이렇게 가능한 방법을 전부 만들어 보는 알고리즘들을 가리켜 `완전 탐색(exhaustive search)`이라고 부른다.

이는 속도가 빠르다는 컴퓨터의 장점을 가장 잘 이용하는 방법이다.

<br/>
<br/>

## 6.2 재귀 호출과 완전 탐색

### 재귀 호출

컴퓨터가 수행하는 많은 작업들은 대개 작은 조각들로 나누어 볼 수 있는데,  
들여다보는 범위가 작아질수록 **각 조각들의 형태가 유사해지는** 작업들을 많이 볼 수 있다.

이런 작업을 구현할 때 유용하게 사용되는 개념이 `재귀 함수(recursive function)`, 혹은 `재귀 호출(recursion)`이다.

<br/>

> `재귀 함수`란 자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 한 조각을 수행하고, 나머지를 **자기 자신을 호출해 실행하는 함수**를 가리킨다.

<br/>

<p align="center"><img width="500" alt="재귀" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/0759093c-5a19-4d45-b607-fdb6fe45320c">

<br/>
<br/>

모든 재귀 함수는 ‘더이상 쪼개지지 않는’ 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다.

이때 쪼개지지 않는 가장 작은 작업들을 가리켜 재귀 호출의 `기저 사례(base case)`라고 한다.

기저 사례를 선택할 때는 존재하는 **모든 입력이 항상 기저 사례의 답을 이용해 계산될 수 있도록** 신경써야 한다.

<br/>

입력이 잘못되거나 범위에서 벗어난 경우도 기저 사례로 택해서 맨 처음에 처리하면 간결한 코드를 작성하는데에 유용하다.

재귀 함수는 항상 한군데 이상에서 호출되기 때문에, 이는 반복적인 코드를 제거하는 데 큰 도움이 된다.

<br/>

### 시간 복잡도 분석

완전 탐색 알고리즘의 시간 복잡도를 계산하는 것은 비교적 단순하다.

완전 탐색은 가능한 답 후보들을 모두 만들어 보기 때문에, 시간 복잡도를 계산하기 위해서는 **가능한 후보의 수를 전부 세어 보기만 하면 된다.**

<br/>

### 완전 탐색 레시피

어떤 문제를 완전 탐색으로 해결하기 위해 필요한 과정은 다음과 같다.

이는 어떤 식으로 문제를 처음 접근해야 할지에 대한 대략적인 지침이라고 생각하면 된다.

<br/>

1. 최대 크기의 입력을 가정했을 대 답의 개수를 계산하고 이들을 모두 제한 시간 안에 생성할 수 있을지를 가늠한다.
    - 완전 탐색의 소요 시간은 가능한 답의 수에 정확히 비례한다.
    - 만약 시간 안에 계산할 수 없다면 다른 설계 패러다임을 적용해야 한다.
2. 가능한 모든 답의 후보를 만드는 과정을 여러 개의 선택으로 나눈다.
3. 그중 하나의 조각을 선택해 **답의 일부를 만들고, 나머지 답을 재귀 호출을 통해 완성한다.**
4. 조각이 하나밖에 남지 않은 경우, 혹은 하나도 남지 않은 경우에는 답을 생성했으므로 이것을 기저 사례로 선택해 처리한다.

<br/>

### 이론적 배경: 재귀 호출과 부분 문제

- `문제(problem)` : 재귀 호출을 논의할 때 ‘문제’란, 항상 수행해야 할 작업과 그 작업을 적용할 자료의 조합을 의미한다.
- `부분 문제(subproblem)` : 문제를 구성하는 조각들 중 하나로, 원래 문제의 일부이다.

<br/>
<br/>

## 6.7 최적화 문제

> `최적화 문제(Optimization problem)`  
> : 문제의 답이 여러 개이고, **어떤 기준에 따라 가장 ‘좋은’ 답**을 찾아 내는 문제들

<br/>

e.g., n개의 사과 중 r개를 골라서 무게의 합을 최대화하는 문제

최적화 문제를 해결하는 방법은 여러 가지가 존재한다. : 완전 탐색, 동적 계획법, 조합 탐색 등)

완전 탐색을 통해서는 가능한 답을 모두 생성해 보고 그중 가장 좋은 것을 찾아내면 되기 때문에, 최적화 문제를 풀기 위한 가장 직관적인 방법이다.

<br/>
<br/>

## 6.10 많이 등장하는 완전 탐색 유형

### 모든 순열 만들기

> `순열(permutation)` : 서로 다른 n개의 원소를 **일렬로** 세운 것

주어진 원소의 모든 순열을 생성해서 풀 수 있는 문제는 꽤 자주 만날 수 있다.

단, 가능한 순열의 수는 `n!`이 되는데, n이 10을 넘어간다면 시간 안에 모든 순열을 생성하기 어렵기 때문에 다른 방법을 생각해야 한다.

<br/>

### 모든 조합 만들기

> `조합(combination)` : 서로 다른 n개의 원소 중에서 r개를 **순서 없이** 골라낸 것

경우의 수는 이항 계수 `nCr`로 정의된다.

<br/>

### 2^n가지 경우의 수 만들기

n개의 질문에 대한 답이 예/아니오 중의 하나라고 할 때 존재할 수 있는 답의 모든 조합의 수는 `2^n`가지이다.

각 조합을 하나의 n비트 정수로 표현한다고 생각하면,  
재귀 호출을 사용할 것 없이 1차원 for문 하나로 이 조합들을 간단하게 모두 시도할 수 있다. (16장에서 다룸)
