# 7. 분할 정복

<br/>

## 분할 정복, Divide & Conquer

≈ 각개 격파

1. 주어진 문제를 둘 이상의 부분 문제로 나눈 뒤,
2. 각 문제에 대한 답을 재귀 호출을 이용해 계산하고,
3. 각 부분 문제의 답으로부터 전체 문제의 답을 계산해낸다.

<br/>

분할 정복이 일반적인 재귀 호출과 다른 점은 문제를 한 조각과 나머지 전체로 나누는 대신, **거의 같은 크기의 부분 문제**로 나누는 것이다.

- 좌측 : 일반적 재귀 호출
- 우측 : 분할 정복

<p align="center"><img width="520" alt="일반적 재귀 vs 분할 정복" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/f2275681-698b-4485-881c-c295e300384e">

<br/>
<br/>

### 구성 요소

분할 정복을 사용하는 알고리즘들이 대개 가지고 있는 세 가지 구성 요소는 다음과 같다.

1. 문제를 더 작은 문제로 분할하는 과정 : `divide`
2. 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합하는 과정 : `merge`
3. 더이상 답을 분할하지 않고 곧장 풀 수 있는 매우 작은 문제 : `base case`

<br/>

> 분할 정복을 적용해 문제를 해결하기 위해서는 **문제를 둘 이상의 부분 문제로 나누는** 자연스러운 방법이 있어야 하며,  
> **부분 문제의 답을 조합해 원래 문제의 답을 계산하는** 효율적인 방법이 있어야 한다.

<br/>

### 장점

분할 정복은 많은 경우 같은 작업을 더 빠르게 처리해 준다.

<br/>
<br/>
<br/>

# 예제: 수열의 빠른 합

**1부터 n까지의 합을 구하는** 분할 정복 알고리즘은 다음과 같다.

<p align="center"><img width="450" alt="fastSum" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/63529b8f-6cd5-4b2d-8c28-6c1fd7af0956">

<br/>
<br/>

```cpp
// 필수 조건: n은 자연수
int fastSum(int n) {
    if (n == 1) return 1; // 기저 사례
    if (n % 2 == 1) return fastSum(n - 1) + n;
    return 2 * fastSum(n / 2) + (n / 2) * (n / 2);
}
```

<br/>

### 시간 복잡도 분석

내부에 반복문이 없기 때문에 fastSum()이 종료하는 데 걸리는 시간은 순전히 함수가 호출되는 횟수에 비례하게 된다.

fastSum()은 호출될 때마다 최소한 **두 번에 한 번 꼴로 n이 절반으로 줄어든다.**

→ `O(lgn)`

<br/>
<br/>
<br/>

# 예제: 행렬의 거듭제곱

n×n 크기의 행렬 A가 주어질 때, `A의 거듭제곱(power) A^m`은 **A를 연속해서 m번 곱한 것이다.**

<br/>

m이 매우 클 때 A^m을 구하는 것은 꽤나 시간이 오래 걸리는 작업이다.

- 행렬의 곱셈에 드는 시간 : `O(n^3)`
- m-1번의 곱셈을 통해 A^m을 구하는데 드는 시간 : `O(n^3 × m)`

<br/>

그러나 분할 정복을 이용하면 이 값을 훨씬 빠르게 구할 수 있다.

<p align="center"><img width="200" alt="행렬 거듭제곱 분할" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/b140f61b-a39e-4183-b312-cb59f039369c">

<br/>
<br/>

```cpp
class SquareMatrix; // 정방행렬을 표현하는 클래스

// n×n 크기의 항등 행렬(identity matrix)을 반환하는 함수
SquareMatrix identity(int n);

SquareMatrix pow(const Square Matrix& A, int m) {
    if (m == 0) return identity(A.size()); // 기저 사례: A^0 = I
    if (m % 2 > 0) return pow(A, m - 1) * A;

    // A^m = (A^(m/2)) * (A^(m/2))
    SquareMatrix half = pow(A, m / 2);
    return half * half;
}
```

<br/>
<br/>

## 나누어 떨어지지 않을 때의 분할과 시간 복잡도

m이 홀수일 때 분할을 하는 방법에는 두 가지가 존재한다.

1. `A^m = A × A^(m-1)` : 위 예시에서의 방법
2. `A^m = A^(m//2) × A^(m - m//2)` : e.g., A^7 = A^3 × A^4

<br/>

> 실제로 문제의 크기가 매번 절반에 가깝게 줄어들면 기저 사례에 도달하기까지 걸리는 분할의 횟수가 줄어들기 때문에  
> **대부분의 분할 정복 알고리즘은 가능한 한 절반에 가깝게 문제를 나누고자 한다.**

하지만 이 문제에서는 예외이다.

2번 방식의 분할을 통해서는 A^m을 찾기 위해 계산해야 할 부분 문제의 수가 늘어나기 때문에 오히려 알고리즘을 더 느리게 만든다.  
(더 정확히 말하자면, 값을 중복으로 계산하는 일이 많아진다.)

<p align="center"><img width="700" alt="행렬 거듭제곱에 대한 두 가지 분할 방식의 비교" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/ced2e57a-cd7f-48dc-a0a7-bf20a0505683">

<br/>
<br/>

홀수를 절반으로 나누는 분할 방식은 대문자 O 표기법으로 보면, 결국 **m-1번 곱셈을 하는 것과 다를 바가 없다.**

반면, 홀수에서 1을 빼서 짝수로 만들고 분할을 하는 방식에서는 pow()가 `O(lgm)`개의 거듭제곱에 대해 한 번씩만 호출된다.

<br/>

---

<br/>

> 절반으로 나누는 알고리즘이 큰 효율 저하를 불러오는 이유 : **여러 번 중복되어 계산되면서** 시간을 소모하는 부분 문제들이 있기 때문이다.

- 이런 속성을 `부분 문제가 중복된다(overlapping subproblems)`고 부른다.
- 이는 동적 계획법(8장)이 고안된 계기가 된다.

<br/>
<br/>
<br/>

# 예제: 병합 정렬과 퀵 정렬

**주어진 수열을 크기 순서대로 정렬하는 문제**를 해결하는 수많은 알고리즘 중 가장 널리 쓰이는 것은 `병합 정렬(merge sort)`과 `퀵 정렬(quick sort)`이다.

이 둘은 모두 분할 정복 패러다임을 기반으로 해서 만들어진 것들이다.

<br/>
<br/>

## 병합 정렬, Merge sort

> 각 수열의 크기가 1이 될 때까지 절반씩 쪼개 나간 뒤, 정렬된 부분 배열들을 합쳐나간다.

- 주어진 배열을 가운데서 절반으로 나누는 과정 : `O(1)`
- 각각 나눠서 정렬한 배열들을 하나의 배열로 합치는 병합 과정 : `O(n)`

<p align="center"><img width="450" alt="병합 정렬" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/269774a3-6dab-4cd6-b63a-f29adb3af055">

<br/>
<br/>
<br/>

## 퀵 정렬, Quick sort

> 병합 과정이 필요 없도록, **한쪽의 배열에 포함된 수가 다른 쪽 배열의 수보다 항상 작도록** 배열을 분할한다.

<br/>

`파티션(partition) 단계` : 배열에 있는 수 중 임의의 ‘`기준 수(pivot)`’를 지정한 후, 기준보다 작거나 같은 숫자를 왼쪽, 더 큰 숫자를 오른쪽으로 보내는 과정

- 각 부분 수열의 맨 처음에 있는 수를 기준으로 삼는다. (위 그림에서 동그라미로 표시된 수들)
- 이들보다 작은 수를 왼쪽으로, 큰 것을 오른쪽으로 가게끔 문제를 분해한다.

<p align="center"><img width="380" alt="퀵 정렬" src="https://github.com/eunaJung01/Algorithmic-Problem-Solving-Strategies/assets/86337233/c6c5ce55-caca-4752-9bcb-269282a7a62b">

<br/>
<br/>

위의 분할은 `O(n)`의 시간이 걸리는 복잡한 작업이며, 기준을 어떤 것으로 선택하느냐에 따라서 비효율적인 분할을 불러올 여지가 있다.

하지만 그 덕분에 각 부분 배열이 이미 정렬한 상태가 되어 **별도의 병합 작업이 필요없다**는 장점이 존재한다.

<br/>

---

<br/>

이 두 알고리즘은 분할 정복 패러다임을 사용하는 같은 아이디어로 정렬을 수행하지만,  
**시간이 많이 걸리는 작업**(즉, O(n)의 시간이 걸리는 과정)**을 분할 단계에서 하느냐, 병합 단계에서 하느냐**가 다르다.

이렇게 같은 문제를 해결하는 알고리즘이라도 어떤 식으로 분할하느냐에 따라 다른 알고리즘이 될 수 있다.

<br/>
<br/>

## 시간 복잡도 분석

### 병합 정렬

> 각 단계마다 반으로 나눈 부분 문제를 재귀 호출을 통해 해결한 뒤, 이들의 결과 수열을 합쳐 전체 문제의 답을 계산한다.

<br/>

정렬된 두 부분 수열을 합치는 데는 **두 수열의 길이 합만큼의 반복문을 수행해야 한다.**

즉, 병합 정렬의 수행 시간은 이 병합 과정에 의해 지배된다.

<br/>

아래 단계로 내려갈수록

- 부분 문제의 수는 두 배로 늘어난다.
- 각 부분 문제의 크기는 반으로 줄어든다.

→ **한 단계 내에서 모든 병합에 필요한 총 시간**은 `O(n)`으로 항상 일정하다.

<br/>

문제의 크기는 항상 거의 절반으로 나누어진다.

→ 필요한 단계의 수는 `O(lgn)`이 된다.

<br/>

따라서 병합 정렬의 시간 복잡도는 `O(nlgn)`이다.

<br/>

### 퀵 정렬

퀵 정렬의 수행 시간은 주어진 문제를 두 개의 부분 문제로 나누는 파티션 과정에 의해 지배된다.

<br/>

파티션에는 주어진 수열의 길이에 비례하는 시간이 걸린다. (병합 정렬에서의 병합 과정과 다를 것이 없음)

하지만 분할된 두 부분 문제가 비슷한 크기로 나눠진다는 보장을 할 수는 없다.

- 최악의 경우에 퀵 정렬의 시간 복잡도 : `O(n^2)`
- 평균적으로 부분 문제가 절반에 가깝게 나눠질 때의 시간 복잡도 : `O(nlgn)`

<br/>

따라서 대부분의 퀵 정렬 구현은 가능한 한 절반에 가까운 분할을 얻기 위해 좋은 기준을 뽑는 다양한 방법들을 사용한다.
