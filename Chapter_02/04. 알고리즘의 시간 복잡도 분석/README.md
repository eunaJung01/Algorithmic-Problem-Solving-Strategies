# 4. 알고리즘의 시간 복잡도 분석

<br/>

> 💡 **알고리즘, algorithm**  
> 어떤 작업이 주어졌을 때 컴퓨터가 이 작업을 해결하는 방법

**문제를 해결하는 방법 그 자체**를 말하기 때문에, 완전히 달라 보이거나 다른 언어로 쓰인 프로그램이라고 해도  
같은 원리에 따라 동작한다면 같은 알고리즘을 사용한다고 할 수 있다.

<br/>

한 문제를 해결하는 데 여러 개의 알고리즘이 존재한다면 그중 어떤 알고리즘을 만드는 법을 배워야 할까?

알고리즘을 평가하는 두 가지의 큰 기준은 알고리즘이 사용하는 `시간`과 `공간`이다.

<br/>

#### 시간

> 알고리즘이 적은 시간을 사용한다 = 더 빠르게 동작한다

알고리즘의 수행 속도와 특성을 분석하는 능력을 키울 필요가 있다.

<br/>

#### 공간

> 알고리즘이 적은 공간을 사용한다 = 더 적은 용량의 메모리를 사용한다

<br/>

이 두 기준은 서로 상충하는 경우가 많다. (메모리 사용량을 희생해 속도를 높이거나, 속도를 희생해서 메모리 사용량을 줄임)

<br/>
<br/>

## 4.1 도입

좀더 빠른 알고리즘을 만들기 위해 가장 먼저 해야 할 일은 바로 **알고리즘의 속도를 어떻게 측정할지**를 정하는 것이다.

<br/>

### 반복문이 지배한다

한 가지 항목이 전체의 대소를 좌지우지하는 것을 `지배한다(dominate)`고 표현한다.

알고리즘의 수행 시간을 지배하는 것은 바로 **반복문**이다.

따라서 대개 알고리즘의 수행 시간은 **반복문의 수행되는 횟수**로 측정하며, 반복문의 수행 횟수는 입력의 크기에 대한 함수로 표현된다.

<br/>
<br/>

## 4.5 시간 복잡도

> 💡 **시간 복잡도, time complexity**  
> 가장 널리 사용되는 알고리즘의 수행 시간 기준으로,  
> 알고리즘이 실행되는 동안 **수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한 것**

<br/>

이때 ‘기본적인 연산’이라는 것은 더 작게 쪼갤 수 없는 최소 크기의 연산이다.

- 두 부호 있는 32비트 정수의 사칙 연산
- 두 실수형 변수의 대소 비교
- 한 변수에 다른 변수 대입하기

<br/>

가장 깊이 중첩된 반복문의 내부에 있는 기본적 연산들은 더 쪼갤 수 없기 때문에 이것이 시간 복잡도의 대략적인 기준이 된다.

반복문의 내부에 기본적인 연산은 여러 개가 포함되어 있을 수도 있는데, 시간 복잡도를 계산할 때 대개 상수를 무시하기 때문에 이는 신경쓰지 않아도 된다.

<br/>

> 시간 복잡도가 높다 = 입력의 크기가 증가할 때 알고리즘의 수행 시간이 더 빠르게 증가한다

그러나 시간 복잡도가 낮다고 해서 언제나 더 빠르게 동작하는 것은 아니고, **시간 복잡도가 낮은 알고리즘은 입력이 더 커지면 커질수록 더 효율적인 것이다.**

(문제에서 해결할 입력의 크기가 매우 작을 경우, 시간 복잡도는 큰 의미를 갖지 못할 수도 있음)

<br/>

### 입력의 종류에 따른 수행 시간의 변화

입력이 어떤 형태로 구성되어 있는지도 수행 시간에 영향을 미친다.

즉, 입력의 종류에 따라 수행 시간이 달라질 수 있다.

<br/>

이러한 경우를 고려하기 위해서 아래 각각에 대한 수행 시간을 각각 따로 계산한다.

- `최선의 경우`
- `최악의 경우`
- `평균적인 경우`

<br/>

이 세 개의 기준 중 대개 사용하는 것은 **최악의 수행 시간** 혹은 **수행 시간의 기대치**이다.

많은 경우 이 두 기준은 따로 구분되지 않고 쓰이는데, 여러 알고리즘에서 이 두 기준이 거의 같기 때문이다.

<br/>

### 점근적 시간 표기: O 표기

시간 복잡도는 알고리즘의 수행 시간을 표기하는 방법이지만, 계산하기가 너무 힘들다.

따라서 가장 깊이 중첩된 반복문 만을 고려했던 것처럼 전체 수행 시간에 큰 영향을 미치지 않는 상수 부분은 무시하고 반복문의 반복 수만 고려하게 된다.

<br/>

여기서 한 발짝 더 나아가, 이것을 더욱 간단하게 표현한 `대문자 O 표기법(Big-O Notation)`이라는 것을 사용해 알고리즘의 수행 시간을 표기한다.

이는 **주어진 함수에서 가장 빨리 증가하는 항만을 남긴 채** 나머지를 다 버리는 표기법이다.

즉, 최고차항을 제외한 모든 것을 들어내는 것이다.

<br/>

e.g.,
<p align="center"><img width="400" alt="O 표기법 예시" src="https://github.com/eunaJung01/Algorithm-Problem-Solving-Strategies/assets/86337233/980842b8-5077-411f-8807-822bdf7410c0">


마지막 예시는 1만큼의 시간밖에 걸리지 않는다고 하여 `상수 시간(constant-time) 알고리즘`이라고 부른다.

<br/>

이 표기법을 쓸 때 알고리즘의 시간 복잡도는 반복문에 의해 결정된다.

따라서 가장 깊이 중첩된 반복문의 수행 횟수를 계산하는 것은 수행 시간의 O 표기를 계산하는 것과 같다.

<br/>

[참고] O를 입으로 소리 내서 읽을 때는 `오더(order)`라고 읽는다.

<br/>

### O 표기법의 의미

O 표기법은 대략적으로 함수의 **상한**을 나타낸다는 데 그 의미가 있다.

그저 각 경우의 수행 시간을 간단히 나타내는 표기법일 뿐, 특별히 최악의 수행 시간과 관련이 있는 것은 아니다.

<br/>
<br/>

## 4.6 수행 시간 어림짐작하기

### 주먹구구 법칙

프로그래밍 대회의 시간 제한은 알고리즘의 시간 복잡도가 아니라 프로그램의 수행 시간을 기준으로 한다.

따라서 어떤 알고리즘이 이 문제를 해결할 수 있을지 알기 위해서는 프로그램을 작성하기 전에  
**입력의 최대 크기**와 **알고리즘의 시간 복잡도**를 보고 수행 시간을 어림짐작할 수 있어야 한다.

<br/>

> 💡 **주먹구구 법칙**  
> 입력의 크기를 시간 복잡도에 대입해서 얻은 반복문 수행 횟수에 대해,  
> **1초당 반복문 수행 횟수가 1억(10^8)을 넘어가면** 시간 제한을 초과할 가능성이 있다.

<p align="center"><img width="650" alt="주먹구구 법칙" src="https://github.com/eunaJung01/Algorithm-Problem-Solving-Strategies/assets/86337233/32dc09ed-0b08-462a-8b1b-33e69a6b0441">

<br/>
<br/>

### 주먹구구 법칙은 주먹구구일 뿐이다.

이는 수많은 가정 위에 지어진 사상누각이기 때문에, 절대로 맹신해서는 안 된다.

시간 복잡도 외에도 다른 요소들을 참조해 시간 안에 수행될지를 판단해야 한다.

<br/>

이때 고려해야 하는 요소로는 다음과 같은 것들이 있다.

- **시간 복잡도가 프로그램의 실제 수행 속도를 반영하지 못하는 경우**
    - O 표기법으로 시간 복잡도를 표현할 때는 상수나 최고차항 이외의 항들을 모두 지워버린다.
    - 따라서 이 시간 복잡도 식에 입력의 최대 크기를 대입한 결과는 어디까지나 적당한 예측 값일 뿐이다.
- **반복문의 내부가 복잡한 경우**
- 메모리 사용 패턴이 복잡한 경우
- 언어와 컴파일러의 차이
